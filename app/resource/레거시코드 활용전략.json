{
    "author": "마이클 C. 페더스",
    "link": "http://openapi.naver.com/l?AAAC2Lyw6CMBREv2bYmBBKy6MLFi20hoWRnUsjFgNBLBDU8PeWSHIX587Mmd7NvGZQEiJAmkIJSAIZQOVIJXi+gSzA2bbh1CUHKPfzveMCgm+w+f+Rgoy8dm4eWbssI6hAqN3V1vb+6/ZpZv9uhz0w9Q5X0yy37umPrTN03RnQgnHCaEq9JSMsjmmSMM7iKPKGDKFcz6ZMtC2rWh/LU5VfCAln3U/268wfgcfgx9cAAAA=",
    "title": "레거시코드 활용전략",
    "image": "http://bookthumb.phinf.naver.net/cover/049/143/04914383.jpg?type=m1&udate=20150509",
    "publisher": "에이콘출판",
    "quotes": [
        {
            "page": "10",
            "text": "코드가 얼마나 훌륭하게 작성되어 있는지 여부와는 상관없이 테스트 루틴이 없는 코드는 불량코드다. 얼마나 멋지게 작성되어 있는가와 객체지향의 사용 여부, 그리고 캡슐화의 정도도 참작요소가 전혀 되지 못한다. 테스트 루틴이 있으면 코드의 동작을 빠르고 검증 가능하게 변경시킬 수 있다. 하지만 테스트 루틴이 없으면 실제로 우리 코드가 더 나아지는지 더 나빠지는지를 알 수 없게 된다. "
        },
        {
            "page": "118",
            "text": "발아 메소드와 포장 메소드는 크게 다르지 않다. 새로운 메소드를 작성하고 기존의 메소드에서 이 새 메소드를 호출하는 경우라면 발아 메소드를 사용하는 것이다. 기존의 메소드를 재 명명하고 새로운 것과 바꿈으로서 새로운 작업을 하고 옛메소드를 호출한다면 포장메소드를 사용하는 것이라고 생각하면 된다. "
        },
        {
            "page": "140",
            "text": "비교를 통한 프로그래밍 : 클래스를 직접 수정하는 대신에 의존관계를 이용해 특징을 추가할 수 있고, 특징 추가 후에 그 특징을 어떻게 통합하면 좋을지 정확히 파악할 수 있다. "
        },
        {
            "page": "148",
            "text": "리펙토링 기법에는 여러가지가 있는데 그 중 Rename Class가 가장 강력하다. 이 클래스는 사람들이 코드를 보는 법에 변경을 가하고 사람들이 이전에 고려하지 못했을 가능성을 알아차리게 만든다. "
        },
        {
            "page": "150",
            "text": "일반적으로 구체적인 메서드를 너무 자주 오버라이드 하면 코드는 복잡해진다. "
        },
        {
            "page": "151",
            "text": "정규화된 계층도 : 정규화된 계층도에서는 어떤 클래스도 하나의 메소드를 하나보다 많게 구현할 수 없다. 달리 말하면, 어떤 클래스도 상위클래스로부터 상속받은 구체적인 메소드를 오버라이드하는 메소드를 가질 수 없다. "
        },
        {
            "page": "204",
            "text": "명령어/쿼리 분리 원칙. "
        },
        {
            "page": "277",
            "text": "스크래치 리펙토링 : 이해하기 어려운 코드를 리펙토링을 수행하면서 코드를 이해한다. 테스트 없이 마음껏 리펙토링하고 코드를 이해한 후에는 그 코드를 버린다. "
        }
    ]
}