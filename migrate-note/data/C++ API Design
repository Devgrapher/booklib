같은 타입의 함수 파라메터를 여러개 사용하지 말자 -65
직교성. 서로 영향을 미치지 않는 것. -69
Weak_ptr : 보통 shared ptr 을 가리키고 있다가 가리키던 포인터의 참조카운트가 0이 되면 weak ptr은 자동으로 null이된다. 따라서 잘못된 참조를 피할 수 있다. -73
선택의 여지가 있다면 항상 비멤버, 비프랜드로 함수를 선언해라(비멤버로 함으로서 private 에 접근을 막는다) -83
코드의 재사용이란 말은 재사용된 코드 간에 연결관계를 만들기도 하고 종종 심각한 연결 관계를 잘라내기 위해서 적은양의 중복코드를 추가하는 것이 더 효과적일 수도 있다. -84
알림(notification)과 옵저버의 차이는 알림은 서로를 알 필요가 없이 불특정 다수에게 보내므로 의존성이 생기지 않는다. 알림은 이벤트를 주고받는 부분을 중앙화 하여 누구에게 보내는지 모른다. 즉, notification service만 알면 된다-94
Pimple이디엄이 성능에 문제가 있다면 빠른 Pimple이디엄을 고려해 볼 수 있다. -111
의존성 삽입(dependency injection)을 활용하자. 싱글톤 남용을 예방하고 테스트작성이 쉽다. -122
싱글톤대신 모노스테이트 패턴을 고려하자. 모든 멤버를 스태틱으로 둔다. -125
생성자가 가상일 수 없는 이유는 생성자 호출시 베이스 클레스의 생성자를 모두 호출 후에 자신의 생성자를 호출하기 때문이다. 하지만 팩토리 메서드는 이를 극복한다. -128
프록시는 원래 클래스와 인터페이스가 동일하고 어댑터는 인터페이스가 다른게 차이점이다. -141
기술적 부채, 워드 커닝햄 -157
기술적 부채가 클때 두가지 방법. 점진적 발전과 급진적 혁신 -160
점진적 혁신을 시도시 façade등을 이용해 낡은 코드를 밑으로 숨기고 차근차근 클라이언트 를 새 api에 맞춘후 테스트 자동화로 버그를 잡아간다. -161
레거시 코드는 오래된 코드가 아니라 테스트 코드가 없는 것. -164
리스코프대체원칙 LSP는 is-a 관계보다 더 제약적이다. -204
Private 상속을 쓰면 베이스 멤버를 노출하지 않으므로 LSP가 깨진코드에 대응할 수 있다. -207
Private 상속에서 using 키워드를 쓰면 베이스 멤버를 public으로 노출 가능하다. -207
하지만 private 상속보다 더 나은 방법은 컴포지션이다. -208
OCP법칙. 한번 배포한 클래스에 기능 추가시에는 새로운 클래스를 추가함으로써 해야한다. 기존 코드를 고치지 않는다. -209
데메테르의 법칙. 함수안에서 파라메터의 함수호출을 통해 얻은 객체의 함수는 호출하지 않는다. -212
만약 클래스를 명명하기 힘들다면 그것은 일반적으로 설계가 충분치 않다는 신호이기도 하다. -214
인터페이스는 대체호 형용사로 이름짓는다. Renderable cleanable -214
NPI, 네임드 파라메터 이디엄 : std::stream이 자신의 참조를 리턴하는 것처럼 연속으로 호출가능하데 하는 구조 -222
template class Stack<int>; 이렇게 cpp파일에 명시적 인스턴스화를 시켜두면 더이상 다른 타입의 템플릿을 생성 불가능해진다. 즉, 암시적 인스턴스화를 하지 않으므로 컴파일이 빨라지고 구현을 cpp에 숨길 수 있다. -286
출력 파라메터는 참조대신 포인터로 넘겨서 출력용임을 표시하자 -300
#define 의 가장큰 문제는 심볼이 없어 디버깅이 어렵다. -304
전방선언은 자기가 개발한 코드에 대해서만 사용하자. (stl에는 쓰지 않는다, 내가 선언한 정방선언이 클라이언트환경에서는 없을 수도 있다) -324
Constexpr  (c++11) double myTable[getsize(2)]; // getsize가 상수를 리턴한다면 문제 없음. -330
초기화 리스트가 좋은 점은 할당연산자 한번만 호출되기 때문이다. 생성자안에서 대입했으면 멤버의 생성자와 할당연산자가 호출 됐을 거다. -332
어설픈 최적화는 모든 악의 근원이다 #도널드 크누스 - 342
Stl의 at() 메서드는 예외를 체크하므로[] 보다 느리다 -353
이진 호환성이란 n버전의 api를 사용해서 구현한 애플리케이션에 단순히 n+1 버전의 api를 복사해 넣거나 새로운 버전의 동적 api 라이브러리를 링크시키는 것만으로도 제대로 동작하는 것을 말한다. -386

