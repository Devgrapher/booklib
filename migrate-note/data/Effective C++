• mutable: const 객체 안에서 멤버를 수정할 수 있게 한다. 멤버의 수정이 사실 논리적으로 문제가 안된다면 사용. -66
• 복사생성자 방지용으로 uncopyable이라는 기반 클래스를 만들어 쓰자. 복사생성자를 private으로 선언만 해둠 -87
• 상속관계에서 기반클래스가 가상소멸자가 아니면 대개 파생클래스의 소멸자가 호출되지 않는다. -90
• 가상 소멸자를 둘지의 기준은 가상함수를 쓰느냐이다. (포인트는 다형성이다) -91
• std:string 은 가상함수가 없으므로 상속하지 말자. -92
• 소멸자에서는 예외가 발생하지 않게하자. 차라리 죽여라. -99
• 기본클래스의 생성자가 호출되는 동안은 가상 함수는 절대로 파생클래스 쪽으로 내려가지 않는다.(이 시점엔 파생클래스가 초기화전이므로. 이 시점엔 기본클래스오 취급된다 ) -101
• operator=을 구현시에는 자기 자신인지 비교하는 코드를 고려하자. 필수는 아니다. 자기대입을 해도 문제 없게 짤 수도 있다 -108
• 복사 후 맞바꾸기 기법(copy and swap) 이 효율적. -110
• 복사생성자 및 대입 연산자 재정의시 기본클래스의 대이터 복사를 빼먹지 말자. -115
• STL 컨테이너에 auto_ptr을 사용해서는 안된다. - 121
    • auto_ptr의 대입연산시 이전 객체의 포인터가 NULL이 되는 특성때문
• 커트터마이징한 쉐어드 포인터를 만들때 Tr1:shared_ptr을 이용해서 만들면 편하다. -126
• 인터페이스는 "맞게 쓰기는 쉽게 틀리게 쓰기는 어렵게" 하자. - 131
• 소멸자가없는 int와같은 기본타입에도 배열로 할당하고 일반 delete를 쓰면 이상 동작이 나타날 수 있따. -134
• New로 생성한 객체를 스마트 포인터로 넣는 코드는 별도의 한 문장으로 만들자. 안그러면 예외 발생시 자원 누출이 일어날 수 있다. - 0
• typedef 에 배열을 정의하지 말다 -134
• Share_ptr 과 교차 dll의 의문. 만약 최초 할당한 dll이 이미 내려갔는데 delete가 일어난다면? 죽지 않을까 -145
• 클래스를 정의한다는 것은 새로운 타입을 하나 정의하는 것과 같습니다. - 146
• 값에 의한 전달 보다는 상수객체 참조자에 의한 전달이 낫다. -149
    • 효율적일 뿐만 아니라 복사손실(Slicing Problem)까지 막아준다.
    • 크기가 작다고 무조건 값에의한 전달이 나은건 아니다. 
        ○ 크기가 작아도 복사생성자에서 비용이 클 수 있다.
        ○ 추후 타입의 크기가 커질 수도 있다.
        ○ 아무리 작아도 기본타입만큼 컴파일러가 최적화 해주지 않는다.
    • 기본제공타입, STL 반복자, 함수 객체, 이 세가지만 값에 의한 전달이 효과적이다. - 154
• 참조자는 존재하는 객체에 붙는 또 다른 이름일 뿐이다. - 155
• 어떤 것이 바뀌면 깨질 가능성을 가진 코드가 늘어날 때 캡슐화의 정도는 그에 반비례해서 작아진다. - 163
• Protected는 public보다 더 많이 보호밭고 있는 것이 절대로 아니다.
• 캡슐화하는 것이 늘어나면 그만큼 밖에서 볼 수 있는 것들이 줄어든다. 밖에서 볼 수 있는 것들이 줄어들면, 그것들을 바꿀 때 필요한 유연성이 커진다. - 165
• 멤버함수 보다는 비멤버 비프랜드 함수가 더 캡슐화 지수가 높다. 왜냐하면 그만큼 private멤버에 접근하는 함수가 줄어드는 것이기 때문이다. - 166
    • 꼭 함수여야 한다는 얘기가 아니다. 다른클래스의 멤버로 옳길 수 있을 것이다.
    • String 클래스와 StringTool클래스로 분리하는 케이스.
    • 혹은 네임스페이스안에 두자. StringStuff 네임스페이스 안의 string 클래스와 외부 함수들.
• 컴파일 의존성을 줄이기 위해 네임스페이스 하나를 두고 여러 개의 헤더로 분류해서 함수를 정의하자. - 168
• 어떤 함수에 들어가는 모든 매개변수에 대해 타입 변환을 해 줄 필요가 있다면, 그 함수는 비멤버이어야 한다. - 0
• 캐스팅도 런타임 부하를 동반할 수 있다. - 189
• 자식객체를 부모클래스 포인터로 캐스팅했을때 주소가다를 수 있다. 이럴때 런타임 오버헤드 발생 -190
• Priavte멤버를 참조로 반환하고 싶으면 const를 붙여라. - 199
• 예외에 안전하게 짜기 : copy and swap 전략 (단 효율을 고려할것..) - 207
• 인라인 요청이 실패할경우 경고를 띄우도록 컴파일러 옵션 설정이 가능하다. -213
• A 클래스 멤버 함수 인자에 B 클래스타입이 있을때 B 클래스의 헤더를 A클래스 헤더에 둘 필요가 없다. 그 함수를 호출하는 쪽에서 그 헤더를 가져다 쓰면 되는 것이다. - 222
• Abc 라는 클래스를 만들면 abcfwd 라는 헤더를 만들어서 참조하는 클래스들의 헤더를 여기서 인클루드 하자. Abc에서는 abcfwd.h를 인클루드 한다. -223


• 템플릿타입으로 받아서 그 타입에 대해 메서드를 호출하는 것은 암시적 인터페이스에 의한 것이다.(일반적인 템플릿이 아닌 객체의 함수호출이었다면 명시적 인터페이스 이다.) - 297
• 템플릿 타입의 특정 타입으로의 인스턴스화가 컴파일타임 다형성이다. - 298
• 명시적 인터페이스는 함수 시그너쳐(선언)에 기반하고 암시적 인터페이스는 유효표현식(해당 함수(인터페이스)의 사용로직)에 기반한다. - 298
• 중첩의존이름(템플릿 타입에 템플릿이 들어간경우 : T::iterator)은 이것이 이름인지 함수인지 컴파일러는 분간할 길이 없다. 따라서 타입으로 쓸때 typename을 붙여주어야 한다. - 303
• 이터레이터가 가르키는 타입 : Std::iterator_traits<T>::value_type (이렇게 하고 변수 선언 가능) - 305
• 템플릿이 또다른 템플릿 기본 클래스를 상속했을때 파생클래스(템플릿)에서 기본 클래스의 멤버 함수 이름을 암시적으로 찾아주지 않는다. (해당 템플릿이 다른 버전으로 특수화 되어 있다면 그 이름이 존재하지 않을 수 있으므로, 대안은 this를 붙여서 호출한다. Using 선언을 한다.) - 310
• 템플릿에서는 코드 중복이 암시적으로 일어난다. (소스코드상으론 중복이 없지만 오브젝트파일 안에서는 각각의 인스턴스마다 모두 같은 코드가 있기 때문.)- 314
    • set_new_handler함수를 호출하여 메모리 부족 예외 발생시 호출할 함수를 지정 가능하다 -349
    • 신기하게 반복되는 템플릿 패턴. CRTP. 싱글톤 템플릿과같이 상속클래스에서 자기 이름으로 부모 템플릿을 구현하여 상속. -356
    • 최신 컴파일러에서는 메모리 할당 실패시 null을 반환하는 대신 예외가 발생한다. -357
    • std::nothrow 를 쓰면 예외대신 null을 리턴한다. -357
        




